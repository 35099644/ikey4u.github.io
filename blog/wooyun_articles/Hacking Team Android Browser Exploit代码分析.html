<html>
<head>
     <title>Hacking Team Android Browser Exploit代码分析 - 腾讯安全中心</title>
	 <meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<body>
<h1>URL:<a href="http://drops.wooyun.org/mobile/7030">http://drops.wooyun.org/mobile/7030</a></h1>

      <p>
        <h1>0x00 前言</h1>

<hr />

<p>Hacking Team 415G泄露资料的<code>vector-exploit-master\src\ht-webkit-Android4-src</code>目录中，包含一份Android Browser exploit代码。用户在浏览器中点击攻击者的链接，便会执行恶意代码。恶意代码利用漏洞获取root权限，并静默安装木马apk。影响Android4.0-4.3版本。</p>

<h1>00x1 漏洞利用的艺术</h1>

<hr />

<p>Exploit代码利用了三个已知的libxslt漏洞，获得对内存地址的完整控制能力。</p>

<ol>
<li>information leak (<a href="https://code.google.com/p/chromium/issues/detail?id=73716">CVE-2011-1202</a>)。</li>
<li>Arbitrary memory read (<a href="https://code.google.com/p/chromium/issues/detail?id=127417">CVE-2012-2825</a>)</li>
<li>Heap-buffer-overflow (<a href="https://code.google.com/p/chromium/issues/detail?id=138673">CVE-2012-2871</a>)</li>
</ol>

<!--more-->

<p>关键流程：</p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/ec1ef9ada0ea9e2ca739aa9c1fe7d93e.jpg" alt="enter image description here" /></p>

<h1>00x2 利用分析</h1>

<hr />

<p>1 申请330块1M大小的内存，并给每一块内存区域打上标记（0x70747468，‘HTTP’）。</p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/f70de019ea0c1cf17e29bbcf406d8db6.jpg" alt="enter image description here" /></p>

<p>2 进行内存搜索，利用CVE-2012-2825可以检查任意内存地址是否为0x70747468（’HTTP’）的能力，找出第一步的标记内存，得到标记内存所在的地址。这里查找内存的时候涉及一个技术细节。</p>

<pre><code>When parsing a XSLT stylesheet containing a DTD, a structure of type xmlEntity is accessed as another type. The value of cur-&gt;ns-&gt;href is then compared with a string(“http://www.w3.org/1999/XSL/Transform"). If not equal, return null.
</code></pre>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/20ebab0679570a12dc43e57fef95b03d.jpg" alt="enter image description here" /></p>

<p>将ns->href和ns->prefix的值改为addr，然后利用二分法在[0x7a703030, 0x79303030]这块内存空间遍历addr，如果找到"http://www.w3.org/1999/XSL/Transform"，会返回一个正确的documentElement。</p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/c54b84dbc2a7d9fdaa2b2d79d0a6fe38.jpg" alt="enter image description here" /></p>

<p>由于这块地址在第一步中已经申请。这块内存我们知道地址并可以随意使用，这一步很关键。可控制的内存约4MB，称为ZoneX。</p>

<p>3 精心修改ZoneX，利用CVE-2011-1202泄漏堆对象的地址和CVE-2012-2871写特定内存地址为特定值的能力，把ZoneX标记为已释放，但JS仍然有读写的能力。</p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/3c08459cc370d9916df36c6f744a85be.jpg" alt="enter image description here" /></p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/1a8a1444eb02777387d2ee2fa72c1f9c.jpg" alt="enter image description here" /></p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/2b549b42eef75afb7c7755b646bf07e1.jpg" alt="enter image description here" /></p>

<p>这一过程相当复杂，暂且跳过。</p>

<p>4 立即申请大量新的ArrayBuffer覆盖ZoneX，由于JS仍然有读写ZoneX的能力，可以马上修改一块符合条件的ArrayBuffer的起始地址为0x00000000，结束地址为0xFFFFFFFF，即整个内存区域。</p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/89b6b7156da937f0a2de88e350d7cef3.jpg" alt="enter image description here" /></p>

<p>5 利用BufferMemoryObject对象，封装对内存地址的操作，至此JS已经得到整个RING3内存的完整读写能力。</p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/ca1682d63a95d3c87521aa569925968e.jpg" alt="enter image description here" /></p>

<p>6 下载小马module.so</p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/bca2ba08b98cd06a645ddce52a2addef.jpg" alt="enter image description here" /></p>

<p>7 结合CVE-2011-1202信息泄漏漏洞，获得libwebcore.so的基址进而获得libc.so的基址。</p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/a959cd46a0aeb9541196122e37632e78.jpg" alt="enter image description here" /></p>

<p>然后在libc和libwebcore中搜索可用的gadget。</p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/cade9f0ec257d4f9f4bdeefcf99d59fd.jpg" alt="enter image description here" /></p>

<p>8 操作内存，覆盖JS对象的虚表，构造假的vtable完成两个gadget的拼接。并使用ROP攻击手法，通过mprotect给堆上的shellcode代码执行的权限，并将执行流程跳转到真正的shellcode。</p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/c0bd33341fdb38f69e707ef94ddb9f32.jpg" alt="enter image description here" /></p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/a77e6f4a77ae5c03800fb29867ae3b6a.jpg" alt="enter image description here" /></p>

<p>9 shellcode中激活已经下载好的小马module.so；</p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/9ed45d5446f8afadb42c2ec0c8707392.jpg" alt="enter image description here" /></p>

<p>10 接下来小马下载ROOT提权程序（exploit，ELF）获取ROOT权限；并留下一个shell /system/bin/rilcap，过程和rcs完全一致。</p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/40f14c09e79f48bacfb243ee7eb69de3.jpg" alt="enter image description here" /></p>

<p>用IDA打开小马，发现其使用了Obfuscator-clang对代码进行了混淆。</p>

<p><img src="https://github.com/ikey4u/WooyunImages/raw/master/pics/9e306e3923e3b2670e5d01217f2a39c2.jpg" alt="enter image description here" /></p>

<p>所涉及的两种root方法，第一种是put_user，另一种是towel。</p>

<p>11 随后，小马在ROOT权限下静默安装黑客指定的木马程序。ALL DONE。</p>

<h1>00x4 总结</h1>

<hr />

<p>从三个POC到一套完整的远程代码执行exploit，是一个复杂而艰难的过程。Hacking Team 的exploit演绎相当之精彩，不得不说是漏洞利用的艺术。从远程代码执行，到下载rcs远程控制客户端，Hacking Team构建了一条完整的黑色链条。看完之后，各位看官会不会和小编一样，背后吓出了一身冷汗。Android Browser Exploit仅仅是Hacking Team泄漏资料中的一个项目，其中的技术点便相当复杂。其所泄漏的项目，不仅包括源代码，还包括大量工程化的工具以及技术文档。仅需简单地配置和修改即可自动化生成黑客工具，很容易被不法分子利用。可想而知，这将大大降低黑产的技术门槛。黑产水平将在短时间内显著提升。守护用户安全之路将任重而道远。</p>      </p>
    
</body>
</html>